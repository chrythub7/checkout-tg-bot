from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
import json
import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Your bot token
TOKEN = "7955701951:AAHhdAGrb8q0YZRIIarxwIUhbkbH-TjK7ZY"

# File per salvare le richieste di notifica
WAITLIST_FILE = "waitlist.json"

# Definizione dei prodotti con stock
products = {
    
    "Gorilla Glue": {"in_stock": True, "stock_qty": 50},
    
    "Amnesia Haze": {"in_stock": True, "stock_qty": 40}, 
    
    "Girl Scout Cookies": {"in_stock": True, "stock_qty": 25},
    
    "OG Kush": {"in_stock": True, "stock_qty": 30}
}

#QuantitÃ  disponibili con sconti realistici
quantities = {
    "5g": {"grams": 5, "discount": 0, "emoji": "ğŸŒ±"},
    "10g": {"grams": 10, "discount": 0, "emoji": "ğŸƒ"},
    "15g": {"grams": 15, "discount": 3, "emoji": "ğŸŒ¿"},  # 3% sconto
    "25g": {"grams": 25, "discount": 5, "emoji": "ğŸ’š"},  # 5% sconto
    "35g": {"grams": 35, "discount": 8, "emoji": "ğŸ”¥"},  # 8% sconto
    "50g": {"grams": 50, "discount": 12, "emoji": "â­"},  # 12% sconto
    "75g": {"grams": 75, "discount": 18, "emoji": "ğŸ’"},  # 18% sconto
    "100g": {"grams": 100, "discount": 25, "emoji": "ğŸ‘‘"} # 25% sconto VIP
}

# Costi di spedizione
shipping_costs = {
    "europa": 10,
    "mondo": 15
}

def load_waitlist():
    """Carica la lista d'attesa dal file"""
    if os.path.exists(WAITLIST_FILE):
        with open(WAITLIST_FILE, 'r') as f:
            return json.load(f)
    return {}

def save_waitlist(waitlist):
    """Salva la lista d'attesa nel file"""
    with open(WAITLIST_FILE, 'w') as f:
        json.dump(waitlist, f, indent=2)

def send_email(contact_info, product_name):
    """Invia email di notifica per prodotto disponibile"""
    sender_email = "your_shop@gmail.com"  # Cambia con la tua email
    sender_password = "your_app_password"  # Usa una password per app Gmail
    
    # Verifica se il contatto Ã¨ un'email valida
    if "@" not in contact_info:
        print(f"Contatto {contact_info} non Ã¨ un'email valida")
        return False
    
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = contact_info
    msg['Subject'] = f"ğŸŒ¿ {product_name} Ã¨ di nuovo disponibile!"
    
    body = f"""
ğŸ‰ Buone notizie!

ğŸŒ¿ {product_name} Ã¨ di nuovo disponibile nel nostro shop!

ğŸ’ QualitÃ  premium garantita
ğŸš€ Spedizione veloce e discreta
ğŸ’° Sconti su quantitÃ  maggiori

Ordina subito prima che finisca di nuovo!

Visita il nostro bot Telegram per ordinare.
    """
    
    msg.attach(MIMEText(body, 'plain'))
    
    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.send_message(msg)
        print(f"Email inviata a {contact_info} per {product_name}")
        return True
    except Exception as e:
        print(f"Errore nell'invio email a {contact_info}: {e}")
        return False

def calculate_price(grams, discount):
    """Calcola il prezzo con sconto applicato"""
    base_price = grams * 10  # 10â‚¬ per grammo
    discounted_price = base_price * (1 - discount / 100)
    return discounted_price

def get_product_names():
    """Ottieni lista nomi prodotti"""
    return list(products.keys())

# Funzione di avvio
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    product_names = get_product_names()
    keyboard = []
    
    for i, product in enumerate(product_names):
        if products[product]["in_stock"]:
            button_text = f"ğŸŒ¿ {product} âœ…"
        else:
            button_text = f"ğŸŒ¿ {product} âŒ (Out of Stock)"
        keyboard.append([InlineKeyboardButton(button_text, callback_data=f"product_{i}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    welcome_text = (
        "ğŸŒ¿ *Benvenuto nel nostro shop premium!* ğŸŒ¿\n\n"
        "âœ¨ *QualitÃ  superiore garantita*\n"
        "ğŸ’° *Sconti fino al 25% su quantitÃ  maggiori*\n"
        "ğŸšš *Spedizione: 10â‚¬ (Europa) | 15â‚¬ (Resto del mondo)*\n"
        "ğŸš€ *Consegna rapida e discreta*\n\n"
        "ğŸ‘‡ Scegli il tuo prodotto preferito:"
    )
    await update.message.reply_text(welcome_text, parse_mode='Markdown', reply_markup=reply_markup)

# Gestione della selezione del prodotto e quantitÃ 
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    if query.data.startswith("product_"):
        # Selezione del prodotto
        product_index = int(query.data.split("_")[1])
        product_names = get_product_names()
        product_name = product_names[product_index]
        
        # Controlla se il prodotto Ã¨ disponibile
        if not products[product_name]["in_stock"]:
            # Prodotto out of stock
            out_of_stock_text = (
                f"ğŸ˜” *Ci dispiace!*\n\n"
                f"ğŸŒ¿ *{product_name}* Ã¨ attualmente *esaurito*\n\n"
                f"ğŸ’¡ *Vuoi essere avvisato quando torna disponibile?*\n"
                f"ğŸ“§ Lascia la tua email o numero di telefono e ti contatteremo appena il prodotto sarÃ  di nuovo in stock!\n\n"
                f"ğŸ‘‡ Scrivi la tua email o telefono:"
            )
            
            keyboard = [
                [InlineKeyboardButton("â¬…ï¸ Torna ai prodotti", callback_data="back_to_products")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Salva il prodotto richiesto per l'utente
            context.user_data['waiting_product'] = product_name
            context.user_data['waiting_contact'] = True
            
            await query.edit_message_text(
                text=out_of_stock_text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
            return
        
        # Prodotto disponibile - mostra quantitÃ 
        keyboard = []
        for qty, info in quantities.items():
            price = calculate_price(info["grams"], info["discount"])
            original_price = info["grams"] * 10
            
            if info["discount"] > 0:
                savings = original_price - price
                button_text = f"{info['emoji']} {qty} - â‚¬{price:.2f} (RISPARMI â‚¬{savings:.2f}!)"
            else:
                button_text = f"{info['emoji']} {qty} - â‚¬{price:.2f}"
            
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"qty_{product_index}_{qty}")])
        
        # Bottone per tornare indietro
        keyboard.append([InlineKeyboardButton("â¬…ï¸ Torna ai prodotti", callback_data="back_to_products")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        stock_qty = products[product_name]["stock_qty"]
        product_text = (
            f"ğŸŒ¿ *{product_name}* - Premium Quality âœ…\n\n"
            f"ğŸ“¦ *Disponibili: {stock_qty}g*\n"
            f"ğŸ’° *Prezzo base: 10â‚¬/g*\n"
            f"ğŸ¯ *PiÃ¹ acquisti, piÃ¹ risparmi!*\n"
            f"ğŸšš *Spedizione: 10â‚¬ (Europa) | 15â‚¬ (Mondo)*\n\n"
            f"ğŸ‘‡ Scegli la tua quantitÃ :"
        )
        
        await query.edit_message_text(
            text=product_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
    
    elif query.data.startswith("qty_"):
        # Selezione quantitÃ  - chiedi zona spedizione
        parts = query.data.split("_")
        product_index = int(parts[1])
        quantity = parts[2]
        
        context.user_data['selected_product_index'] = product_index
        context.user_data['selected_quantity'] = quantity
        
        keyboard = [
            [InlineKeyboardButton("ğŸ‡ªğŸ‡º Europa (10â‚¬)", callback_data="shipping_europa")],
            [InlineKeyboardButton("ğŸŒ Resto del mondo (15â‚¬)", callback_data="shipping_mondo")],
            [InlineKeyboardButton("â¬…ï¸ Indietro", callback_data=f"product_{product_index}")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        shipping_text = (
            "ğŸšš *Seleziona la tua zona di spedizione:*\n\n"
            "ğŸ‡ªğŸ‡º *Europa*: 10â‚¬\n"
            "ğŸŒ *Resto del mondo*: 15â‚¬\n\n"
            "ğŸ‘‡ Scegli la tua zona:"
        )
        
        await query.edit_message_text(
            text=shipping_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
    
    elif query.data.startswith("shipping_"):
        # Calcolo finale con spedizione
        shipping_zone = query.data.split("_")[1]
        product_index = context.user_data.get('selected_product_index')
        quantity = context.user_data.get('selected_quantity')
        
        product_names = get_product_names()
        product_name = product_names[product_index]
        qty_info = quantities[quantity]
        price = calculate_price(qty_info["grams"], qty_info["discount"])
        original_price = qty_info["grams"] * 10
        shipping_cost = shipping_costs[shipping_zone]
        total_price = price + shipping_cost
        
        paypal_link = f"https://paypal.me/example/{total_price:.2f}"
        
        # Messaggio principale
        message_text = f"âœ… *Ottima scelta!*\n\nğŸŒ¿ *{product_name}* - {quantity}\n"
        
        # Aggiunta dettagli sconto se presente
        if qty_info["discount"] > 0:
            savings = original_price - price
            message_text += (
                f"ğŸ’° Prezzo normale: â‚¬{original_price:.2f}\n"
                f"ğŸ‰ *Sconto {qty_info['discount']}%*: -â‚¬{savings:.2f}\n"
                f"ğŸ’ *HAI RISPARMIATO â‚¬{savings:.2f}!*\n\n"
            )
        
        zone_text = "ğŸ‡ªğŸ‡º Europa" if shipping_zone == "europa" else "ğŸŒ Resto del mondo"
        
        message_text += (
            f"ğŸ’³ *Subtotale prodotto: â‚¬{price:.2f}*\n"
            f"ğŸšš *Spedizione {zone_text}: â‚¬{shipping_cost:.2f}*\n"
            f"ğŸ’ *TOTALE FINALE: â‚¬{total_price:.2f}*\n\n"
            f"ğŸš€ *Spedizione veloce e discreta*\n"
            f"ğŸ”’ *Pagamento sicuro*\n\n"
            f"ğŸ‘‡ Procedi al pagamento:\n{paypal_link}"
        )
        
        # Bottoni per altre azioni
        keyboard = [
            [InlineKeyboardButton("ğŸ›’ Aggiungi altro prodotto", callback_data="back_to_products")],
            [InlineKeyboardButton("ğŸ“ Contatta assistenza", url="https://t.me/supportbot")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text=message_text, parse_mode='Markdown', reply_markup=reply_markup)
    
    elif query.data == "back_to_products":
        # Torna alla selezione dei prodotti
        product_names = get_product_names()
        keyboard = []
        
        for i, product in enumerate(product_names):
            if products[product]["in_stock"]:
                button_text = f"ğŸŒ¿ {product} âœ…"
            else:
                button_text = f"ğŸŒ¿ {product} âŒ (Out of Stock)"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"product_{i}")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        back_text = (
            "ğŸŒ¿ *Scegli un altro prodotto premium!* ğŸŒ¿\n\n"
            "ğŸ’ *QualitÃ  garantita al 100%*\n"
            "ğŸ¯ *Maggiori quantitÃ  = maggiori risparmi*\n"
            "ğŸšš *Spedizione: 10â‚¬ (Europa) | 15â‚¬ (Mondo)*\n\n"
            "ğŸ‘‡ Seleziona il tuo prossimo acquisto:"
        )
        await query.edit_message_text(back_text, parse_mode='Markdown', reply_markup=reply_markup)

# Gestione messaggi di testo per email/telefono
async def handle_contact_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.user_data.get('waiting_contact'):
        contact_info = update.message.text
        product_name = context.user_data.get('waiting_product')
        user_id = update.effective_user.id
        
        # Carica e aggiorna waitlist
        waitlist = load_waitlist()
        if product_name not in waitlist:
            waitlist[product_name] = []
        
        # Aggiungi utente alla waitlist se non giÃ  presente
        user_entry = {
            "user_id": user_id,
            "contact_info": contact_info,
            "username": update.effective_user.username or "N/A"
        }
        
        # Controlla se l'utente Ã¨ giÃ  nella lista
        user_exists = any(entry["user_id"] == user_id for entry in waitlist[product_name])
        
        if not user_exists:
            waitlist[product_name].append(user_entry)
            save_waitlist(waitlist)
            
            confirmation_text = (
                f"âœ… *Perfetto!*\n\n"
                f"ğŸ“§ *Contatto salvato*: {contact_info}\n"
                f"ğŸŒ¿ *Prodotto*: {product_name}\n\n"
                f"ğŸ”” *Ti avviseremo appena {product_name} tornerÃ  disponibile!*\n\n"
                f"Grazie per la tua pazienza! ğŸ’š"
            )
        else:
            confirmation_text = (
                f"â„¹ï¸ *Sei giÃ  nella lista d'attesa per {product_name}*\n\n"
                f"Ti contatteremo non appena sarÃ  di nuovo disponibile! ğŸ’š"
            )
        
        keyboard = [
            [InlineKeyboardButton("ğŸ›’ Vedi altri prodotti", callback_data="back_to_products")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            text=confirmation_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )
        
        # Reset stato utente
        context.user_data['waiting_contact'] = False
        context.user_data['waiting_product'] = None

# Funzione per notificare utenti quando prodotto torna in stock (da chiamare manualmente)
async def notify_product_back_in_stock(product_name, application):
    """Notifica tutti gli utenti in attesa che il prodotto Ã¨ tornato disponibile"""
    # Verifica che il prodotto sia effettivamente disponibile
    if not products[product_name]["in_stock"]:
        print(f"{product_name} non Ã¨ disponibile. Nessuna notifica inviata.")
        return
    
    waitlist = load_waitlist()
    
    if product_name in waitlist and waitlist[product_name]:
        notifications_sent = 0
        emails_sent = 0
        
        for user_entry in waitlist[product_name]:
            try:
                user_id = user_entry["user_id"]
                contact_info = user_entry["contact_info"]
                
                # Invia email se il contatto Ã¨ un'email
                if "@" in contact_info:
                    if send_email(contact_info, product_name):
                        emails_sent += 1
                
                # Invia notifica Telegram
                notification_text = (
                    f"ğŸ‰ *Buone notizie!*\n\n"
                    f"ğŸŒ¿ *{product_name}* Ã¨ di nuovo disponibile!\n\n"
                    f"ğŸ›’ *Ordina subito prima che finisca di nuovo!*\n\n"
                    f"Usa /start per vedere tutti i prodotti disponibili."
                )
                
                await application.bot.send_message(
                    chat_id=user_id,
                    text=notification_text,
                    parse_mode='Markdown'
                )
                notifications_sent += 1
                
            except Exception as e:
                print(f"Errore nell'invio notifica a {user_id}: {e}")
        
        # Rimuovi utenti notificati dalla waitlist
        waitlist[product_name] = []
        save_waitlist(waitlist)
        print(f"Notifiche inviate per {product_name}: {notifications_sent} Telegram, {emails_sent} email")

# Comando per notificare manualmente (solo per admin)
async def notify_stock_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando per notificare che un prodotto Ã¨ tornato in stock"""
    if len(context.args) != 1:
        await update.message.reply_text("Uso: /notify_stock <nome_prodotto>")
        return
    
    product_name = context.args[0]
    if product_name not in products:
        await update.message.reply_text(f"Prodotto '{product_name}' non trovato!")
        return
    
    # Invia notifiche
    await notify_product_back_in_stock(product_name, context.application)
    await update.message.reply_text(f"âœ… Notifiche inviate per {product_name}!")

# Comando per testare le notifiche
async def test_notify_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Testa l'invio di notifiche per tutti i prodotti in waitlist"""
    waitlist = load_waitlist()
    
    for product_name in waitlist:
        if waitlist[product_name]:  # Se ci sono utenti in attesa
            await notify_product_back_in_stock(product_name, context.application)
    
    await update.message.reply_text("âœ… Tutte le notifiche sono state inviate!")

# Avvio dell'applicazione
app = ApplicationBuilder().token(TOKEN).build()
app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("notify_stock", notify_stock_command))
app.add_handler(CommandHandler("test_notify", test_notify_command))
app.add_handler(CallbackQueryHandler(button))
app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_contact_info))

if __name__ == "__main__":
    app.run_polling()